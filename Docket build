Error: template: ingress/charts/kong-support-infra/templates/secretproviderclass.yaml:5:25: executing "ingress/charts/kong-support-infra/templates/secretproviderclass.yaml" at <{{template "kong.namespace" .}}>: template "kong.namespace" not defined
2025-07-03T14:21:35.3072431Z 

Error: Unable to continue with install: CustomResourceDefinition "kongclusterplugins.configuration.konghq.com" in namespace "" exists and cannot be imported into the current release: invalid ownership metadata; label validation error: missing key "app.kubernetes.io/managed-by": must be set to "Helm"; annotation validation error: missing key "meta.helm.sh/release-name": must be set to "kong"; annotation validation error: missing key "meta.helm.sh/release-namespace": must be set to "kong"
2025-07-03T06:56:45.1994997Z 

2025-07-03T06:42:38.4756293Z Release "kong" does not exist. Installing it now.
2025-07-03T06:42:38.9032601Z Error: template: ingress/charts/gateway/templates/service-kong-udp-proxy.yaml:2:20: executing "ingress/charts/gateway/templates/service-kong-udp-proxy.yaml" at <.Values.udpProxy.enabled>: nil pointer evaluating interface {}.enabled
2025-07-03T06:42:38.9059726Z 

,"error":"RequestError: send request failed\ncaused by: Post \"https://logs.ap-south-1.amazonaws.com/\": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)

1] [error] [upstream] connection #31 to logs.ap-south-1.amazonaws.com:443 timed out after 10 seconds
[2025/06/24 07:11:11] [error] [output:cloudwatch_logs:cloudwatch_logs.1] Failed to create log stream
[2025/06/24 07:11:11] [error] [upstream] connection #218 to logs.ap-south-1.amazonaws.com:443 timed out after 10 seconds
[2025/06/24 07:11:11] [error] [output:cloudwatch_logs:cloudwatch_logs.1] Failed to send events
[2025/06/24 07:11:11] [error] [aws_client] connection initialization error
[2025/06/24 07:11:11] [error] [output:cloudwatch_logs:cloudwatch_logs.0] Failed to create log stream
[2025/06/24 07:11:11] [error] [output:cloudwatch_logs:cloudwatch_logs.0] Failed to send events
[2025/06/24 07:11:11] [error] [aws_client] connection initialization error
[2025/06/24 07:11:11] [error] [output:cloudwatch_logs:cloudwatch_logs.0] Failed to create log stream
[2025/06/24 07:11:11] [error] [output:cloudwatch_logs:cloudwatch_logs.0] Failed to send events
[2025/06/24 07:11:11] [error] [aws_client] connection initialization error

E0620 10:59:38.253663       1 server.go:151] Failure getting secret values from provider type secretsmanager: Failed to fetch secret from all regions: uat-kong-secret
I0620 10:59:38.811586       1 server.go:124] Servicing mount request for pod ingress-kong-66cdd548f4-jwz68 in namespace kong using service account kong-serviceaccount with region(s) ap-south-1
I0620 10:59:38.816197       1 auth.go:123] Role ARN for kong:kong-serviceaccount is arn:aws:iam::756821680655:role/cpg_secret_manager_role_kong_secret_uat


Warning  FailedMount  0s (x3 over 4m1s)  kubelet            MountVolume.SetUp failed for volume "kongpluginsecret" : rpc error: code = DeadlineExceeded desc = context deadline exceeded


To deploy a Java application (Docker image) to Amazon EKS (Elastic Kubernetes Service) using Azure DevOps, you can follow these high-level steps:

‚∏ª

‚úÖ Overview of the Pipeline
	1.	Build Java Application and Docker Image
	2.	Push Docker Image to Amazon ECR (Elastic Container Registry)
	3.	Deploy to EKS using kubectl

‚∏ª

üîß Prerequisites
	‚Ä¢	Java application with a Dockerfile
	‚Ä¢	EKS cluster running and accessible
	‚Ä¢	Amazon ECR repository created
	‚Ä¢	Azure DevOps service connection to AWS (via service principal or IAM credentials)
	‚Ä¢	kubectl and aws CLI installed in the agent or pipeline

‚∏ª

üìÅ Project Structure (Example)

.
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ deployment.yaml       # Kubernetes manifest
‚îú‚îÄ‚îÄ service.yaml          # Kubernetes service (optional)
‚îú‚îÄ‚îÄ src/                  # Java source
‚îú‚îÄ‚îÄ pom.xml or build.gradle


‚∏ª

üß™ Sample Azure DevOps Pipeline (YAML)

trigger:
- main

variables:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: your-ecr-repo-name
  ECR_REGISTRY: <your_aws_account_id>.dkr.ecr.$(AWS_REGION).amazonaws.com
  IMAGE_TAG: $(Build.BuildId)

stages:
- stage: BuildAndPush
  jobs:
  - job: Build
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: GitVersion@5
      displayName: 'Determine version'

    - task: Maven@3
      displayName: 'Build Java Project'
      inputs:
        mavenPomFile: 'pom.xml'
        goals: 'package'

    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        command: build
        Dockerfile: '**/Dockerfile'
        tags: |
          $(IMAGE_TAG)

    - task: ECRPushImage@1
      displayName: 'Push to ECR'
      inputs:
        awsCredentials: 'AWS-Service-Connection'
        regionName: '$(AWS_REGION)'
        imageSource: 'imageId'
        sourceImageId: '$(Build.Repository.Name):$(IMAGE_TAG)'
        repositoryName: '$(ECR_REPOSITORY)'
        pushTag: '$(IMAGE_TAG)'

- stage: Deploy
  jobs:
  - job: DeployToEKS
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AWSCLI@1
      inputs:
        awsCredentials: 'AWS-Service-Connection'
        regionName: '$(AWS_REGION)'
        command: 'eks update-kubeconfig --name your-eks-cluster-name'

    - script: |
        kubectl apply -f deployment.yaml
        kubectl apply -f service.yaml
      displayName: 'Deploy to EKS'


‚∏ª

üìú Sample deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: java-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: java-app
  template:
    metadata:
      labels:
        app: java-app
    spec:
      containers:
      - name: java-app
        image: <your_aws_account_id>.dkr.ecr.us-east-1.amazonaws.com/your-ecr-repo-name:latest
        ports:
        - containerPort: 8080


‚∏ª

üîê Notes on Authentication
	‚Ä¢	Use AWS Service Connection in Azure DevOps:
	‚Ä¢	Go to Project Settings ‚Üí Service Connections ‚Üí Add new ‚Üí AWS
	‚Ä¢	Use an IAM user with ECR and EKS permissions

‚∏ª

üìå Optional Enhancements
	‚Ä¢	Add Helm support for cleaner deployment
	‚Ä¢	Use kubectl rollout status or kubectl get pods for post-deploy verification
	‚Ä¢	Add environment-specific deployment (e.g., dev/staging/prod)

‚∏ª

Would you like me to:
	‚Ä¢	Help you write the Dockerfile?
	‚Ä¢	Add Helm support?
	‚Ä¢	Generate the Java sample project too?

Let me know what you‚Äôd like to go deeper into.
